#!/usr/bin/env ruby

$:.unshift File.join(File.dirname(__FILE__), "..", "lib")

#require "byebug"
require "roku_builder"
require "optparse"
require "pathname"

options = {}
options[:config] = '~/.roku_config.rb'
options[:stage] = 'production'
options[:update_manifest] = false
options[:fetch] = false
options[:device] = 'default'

OptionParser.new do |opts|
  opts.banner = "Usage: roku <command> [options]"

  opts.on("-l", "--sideload", "Command: Sideload an app") do |s|
    options[:sideload] = s
  end

  opts.on("-p", "--package", "Command: Package an app") do |p|
    options[:package] = p
  end

  opts.on("-t", "--test", "Command: Test an app") do |t|
    options[:test] = t
  end

  opts.on("-L", "--deeplink", "Command: Deeplink into app. Requires mgid and type options.") do |d|
    options[:deeplink] = d
  end

  opts.on("-C", "--configure", "Command: Copy base configuration file to the --config location. Default: '~/.roku_config.rb'") do |c|
    options[:configure] = c
  end

  opts.on("-d", "--delete", "Command: Delete the currently sideloaded app") do |d|
    options[:delete] = d
  end

  opts.on("-N", "--navigate CMD", "Command: send the given command to the roku") do |n|
    options[:navigate] = n
  end

  opts.on("-R", "--restart", "Command: restart the roku device") do |r|
    options[:restart] = r
  end

  opts.on("-y", "--type TEXT", "Command: type the given text on the roku device") do |t|
    options[:text] = t
  end

  opts.on("-b", "--build", "Command: build a zip to be sideloaded") do |b|
    options[:build] = b
  end

  opts.on("-r", "--ref REF", "Git referance to use for sideloading") do |r|
    options[:ref] = r
  end

  opts.on("-w", "--working", "Use working directory to sideload or test") do |w|
    options[:working] = w
  end

  opts.on("-s", "--stage STAGE", "Set the stage to use. Default: 'production'") do |b|
    options[:stage] = b
    options[:set_stage] = true
  end

  opts.on("-n", "--no-manifest-update", "Do not update the manifest file while packaging. DEPRICATED: this is now the default.") do |n|
    print "DEPRICATED: --no-manifest-update is now the default"
    options[:update_manifest] = false
  end

  opts.on("-M", "--manifest-update", "Update the manifest file while packaging") do |n|
    options[:update_manifest] = false
  end

  opts.on("-f", "--fetch", "Preform a `git fetch --all` on the repository before building or sideloading.") do
    options[:fetch] = true
  end

  opts.on("-m", "--mgid MGID", "MGID to deeplink to. DEPRICATED: use -o mgid:<mgid>") do |m|
    print "DEPRICATED: don't use --mgid <mgid>, use --deeplink-options mgid:<mgid> instead"
    options[:mgid] = m
  end

  opts.on("-T", "--content-type TYPE", "Content Type of MGID. DEPRICATED: use -o content_type:<type>") do |t|
    print "DEPRICATED: don't use --content-type <type>, use --deeplink-options content_type:<type> instead"
    options[:content_type] = t
  end

  opts.on("-o", "--deeplink-options TYPE", "Additional deeplink options. (eg. a:b, c:d,e:f)") do |o|
    options[:deeplink_options] = o
  end

  opts.on("-c", "--config CONFIG", "Set a custom config file. Default: '~/.roku_config.rb'") do |c|
    options[:config] = c
  end

  opts.on("-D", "--device ID", "Use a different device corresponding to the given ID") do |d|
    options[:device] = d
  end

  opts.on("-P", "--project ID", "Use a different project") do |p|
    options[:project] = p
  end

  opts.on("-h", "--help", "Show this message") do |h|
    puts opts
    exit
  end

  opts.on("-v", "--version", "Show version") do
    puts RokuBuilder::Version
    exit
  end
end.parse!

commands = 0
commands += 1 if options[:sideload]
commands += 1 if options[:package]
commands += 1 if options[:test]
commands += 1 if options[:deeplink]
commands += 1 if options[:configure]
commands += 1 if options[:delete]
commands += 1 if options[:navigate]
commands += 1 if options[:restart]
commands += 1 if options[:text]
commands += 1 if options[:build]

if commands > 1
  puts "Only one command is allowed"
  abort
end
if commands < 1
  puts "A command is required"
  abort
end

if options[:configure]
  ### Copy Config File ###
  FileUtils.copy(File.expand_path(File.join(File.dirname(__FILE__), '..', 'config.rb.example')),
    File.expand_path(options[:config]))
  exit
end

# load config
config_file = File.expand_path(options[:config])
unless File.exists?(config_file)
  puts "Missing config file: #{config_file}"
  abort
end
load config_file

#set project
unless options[:project]
  path = `pwd`
  project = nil
  $config[:projects].each_pair {|key,value|
    if value.is_a?(Hash)
      repo_path = Pathname.new(value[:repo_dir]).realdirpath.to_s
      if path.start_with?(repo_path)
        project = key
        break
      end
    end
  }
  if project
    options[:project] = project
  else
    if $config[:projects][:default].is_a?(Hash)
      puts "DEPRICATED CONFIG: default under projects should be a key for the default project. See example config."
      options[:project] = :default
    else
      options[:project] = $config[:projects][:default]
    end
  end
end

# setup configs
device_config = $config[:device_info][options[:device].to_sym]
project_config = $config[:projects][options[:project].to_sym]
unless device_config
  puts "FATAL: Unkown device id"
  abort
end
unless project_config
  puts "FATAL: Unknown project id"
  abort
end
stage = options[:stage].to_sym
sideload_config = {
  root_dir: project_config[:repo_dir],
  branch: project_config[stage][:branch],
  update_manifest: false,
  fetch: options[:fetch]
}
build_config = {
  root_dir: project_config[:repo_dir],
  branch: project_config[stage][:branch],
  fetch: options[:fetch]
}

if options[:sideload]
  ### Sideload App ###
  # Check Options
  count = 0
  count += 1 if options[:ref]
  count += 1 if options[:set_stage]
  count += 1 if options[:working]
  if count > 1
    puts "FATAL: only use one of --ref, --working or --stage"
    abort
  end
  # Set options
  loader = RokuBuilder::Loader.new(**device_config)
  if options[:ref]
    sideload_config[:branch] = options[:ref]
  end
  if options[:working]
    sideload_config[:branch] = nil
  end
  # Run
  success = loader.sideload(**sideload_config)
  puts "FATAL: Failed to sideload app" unless success
elsif options[:package]
  ### Package App ###
  stage_config = project_config[stage]
  keyer = RokuBuilder::Keyer.new(**device_config)
  loader = RokuBuilder::Loader.new(**device_config)
  packager = RokuBuilder::Packager.new(**device_config)
  # Key Roku
  success = keyer.rekey(**stage_config[:key])
  puts "WARNING: Key did not change" unless success
  # Sideload App
  sideload_config[:update_manifest] = options[:update_manifest]
  build_version = loader.sideload(**sideload_config)
  unless build_version
    puts "FATAL: Failed to sideload app"
    abort
  end
  # Package App
  package_config = {
    app_name_version: "#{project_config[:app_name]} - #{stage} - #{build_version}",
    password: stage_config[:key][:password],
    out_file: File.join("/tmp", "#{project_config[:app_name]}_#{stage}_"+
      "#{build_version}.pkg")
  }
  success = packager.package(**package_config)
  if success
    puts "Signing Successful: #{package_config[:out_file]}"
  else
    puts "FATAL: Signing Failed"
  end
elsif options[:test]
  ### Test App ###
  tester = RokuBuilder::Tester.new(**device_config)
  test_config = {
    root_dir: project_config[:repo_dir],
    branch: project_config[:testing][:branch],
  }
  if options[:working]
    test_config[:branch] = nil
  end
  tester.run_tests(**test_config)
elsif options[:deeplink]
  ### Deeplink to App ###
  deeplink_config = {}
  if  options[:mgid] and options[:content_type]
    deeplink_config = {
      mgid: options[:mgid],
      content_type: options[:content_type]
    }
  end
  if options[:deeplink_options]
    opts = options[:deeplink_options].split(/,\s*/)
    opts.each do |opt|
      opt = opt.split(":")
      key = opt.shift.to_sym
      value = opt.join(":")
      deeplink_config[key] = value
    end
  end
  unless deeplink_config.keys.count > 0
    puts "FATAL: must supply at least one option for deeplinking"
    abort
  end
  linker = RokuBuilder::Linker.new(**device_config)
  linker.link(**deeplink_config)
elsif options[:delete]
  loader = RokuBuilder::Loader.new(**device_config)
  loader.unload()
elsif options[:navigate]
  navigator = RokuBuilder::Navigator.new(**device_config)
  unless navigator.nav(command: options[:navigate].to_sym)
    puts "FATAL: command not sent"
    abort
  end
elsif options[:restart]
  navigator = RokuBuilder::Navigator.new(**device_config)
  navigator.nav(command: :home)
  navigator.nav(command: :up)
  sleep(0.9)
  navigator.nav(command: :select)
  navigator.nav(command: :up)
  sleep(0.9)
  navigator.nav(command: :select)
  navigator.nav(command: :up)
  navigator.nav(command: :up)
  navigator.nav(command: :up)
  navigator.nav(command: :up)
  sleep(0.9)
  navigator.nav(command: :select)
  navigator.nav(command: :select)
elsif options[:text]
  navigator = RokuBuilder::Navigator.new(**device_config)
  navigator.type(text: options[:text])
elsif options[:build]
  # Check Options
  count = 0
  count += 1 if options[:ref]
  count += 1 if options[:set_stage]
  count += 1 if options[:working]
  if count > 1
    puts "FATAL: only use one of --ref, --working or --stage"
    abort
  end
  # Set options
  loader = RokuBuilder::Loader.new(**device_config)
  if options[:ref]
    build_config[:branch] = options[:ref]
  end
  if options[:working]
    build_config[:branch] = nil
  end
  build_version = RokuBuilder::ManifestManager.build_version(root_dir: build_config[:root_dir])
  build_config[:outfile] = "/tmp/#{project_config[:app_name]}_#{stage}_#{build_version}.zip"
  # Run
  outfile = loader.build(**build_config)
  print "Build: #{outfile}\n"
end
