#!/usr/bin/env ruby

$:.unshift File.join(File.dirname(__FILE__), "..", "lib")

require "byebug"
require "roku_builder"
require "optparse"
require "pathname"

options = {}
options[:config] = '~/.roku_config.json'
options[:stage] = 'production'
options[:update_manifest] = false
options[:fetch] = false

OptionParser.new do |opts|
  opts.banner = "Usage: roku <command> [options]"

  opts.on("-l", "--sideload", "Command: Sideload an app") do |s|
    options[:sideload] = s
  end

  opts.on("-p", "--package", "Command: Package an app") do |p|
    options[:package] = p
  end

  opts.on("-t", "--test", "Command: Test an app") do |t|
    options[:test] = t
  end

  opts.on("-L", "--deeplink", "Command: Deeplink into app. Requires mgid and type options.") do |d|
    options[:deeplink] = d
  end

  opts.on("--configure", "Command: Copy base configuration file to the --config location. Default: '~/.roku_config.json'") do |c|
    options[:configure] = c
  end

  opts.on("--validate", "Command: Validate configuration'") do |v|
    options[:validate] = v
  end

  opts.on("-d", "--delete", "Command: Delete the currently sideloaded app") do |d|
    options[:delete] = d
  end

  opts.on("-N", "--navigate CMD", "Command: send the given command to the roku") do |n|
    options[:navigate] = n
  end

  opts.on("-R", "--restart", "Command: restart the roku device") do |r|
    options[:restart] = r
  end

  opts.on("-y", "--type TEXT", "Command: type the given text on the roku device") do |t|
    options[:text] = t
  end

  opts.on("-b", "--build", "Command: build a zip to be sideloaded") do |b|
    options[:build] = b
  end

  opts.on("-m", "--monitor TYPE", "Command: run telnet to monitor roku log") do |m|
    options[:monitor] = m
  end

  opts.on("-u", "--update-manifest", "Command: update the manifest file") do |u|
    options[:update] = u
  end

  opts.on("-r", "--ref REF", "Git referance to use for sideloading") do |r|
    options[:ref] = r
  end

  opts.on("-w", "--working", "Use working directory to sideload or test") do |w|
    options[:working] = w
  end

  opts.on("-c", "--current", "Use current directory to sideload or test. Overides any project config") do |w|
    options[:current] = true
  end

  opts.on("-s", "--stage STAGE", "Set the stage to use. Default: 'production'") do |b|
    options[:stage] = b
    options[:set_stage] = true
  end

  opts.on("-M", "--manifest-update", "Update the manifest file while packaging") do |n|
    options[:update_manifest] = true
  end

  opts.on("-i", "--inspect", "Print inspection information while packaging") do |n|
    options[:inspect] = true
  end

  opts.on("-f", "--fetch", "Preform a `git fetch --all` on the repository before building or sideloading.") do
    options[:fetch] = true
  end

  opts.on("-o", "--deeplink-options TYPE", "Additional deeplink options. (eg. a:b, c:d,e:f)") do |o|
    options[:deeplink_options] = o
  end

  opts.on("-e", "--edit PARAMS", "Edit config params when configuring. (eg. a:b, c:d,e:f)") do |p|
    options[:edit_params] = p
  end

  opts.on("--config CONFIG", "Set a custom config file. Default: '~/.roku_config.rb'") do |c|
    options[:config] = c
  end

  opts.on("-D", "--device ID", "Use a different device corresponding to the given ID") do |d|
    options[:device] = d
  end

  opts.on("-P", "--project ID", "Use a different project") do |p|
    options[:project] = p
  end

  opts.on("-O", "--out PATH", "Output file/folder. If PATH ends in .pkg/.zip, file is assumed, otherwise folder is assumed") do |o|
    options[:out] = o
  end

  opts.on("-h", "--help", "Show this message") do |h|
    puts opts
    exit
  end

  opts.on("-v", "--version", "Show version") do
    puts RokuBuilder::VERSION
    exit
  end
end.parse!

commands = 0
commands += 1 if options[:sideload]
commands += 1 if options[:package]
commands += 1 if options[:test]
commands += 1 if options[:deeplink]
commands += 1 if options[:configure]
commands += 1 if options[:validate]
commands += 1 if options[:delete]
commands += 1 if options[:navigate]
commands += 1 if options[:restart]
commands += 1 if options[:text]
commands += 1 if options[:build]
commands += 1 if options[:update]
commands += 1 if options[:monitor]

if commands > 1
  puts "FATAL: Only one command is allowed"
  abort
end
if commands < 1
  puts "FATAL: A command is required"
  abort
end

count = 0
count += 1 if options[:ref]
count += 1 if options[:set_stage]
count += 1 if options[:working]
count += 1 if options[:current]
if count > 1
  puts "FATAL: only use one of --ref, --working, --current or --stage"
  abort
end

if options[:current]
  unless options[:build] or options[:sideload]
    puts "FATAL: can only sideload or build 'current' directory"
    abort
  end
end

if options[:configure]
  source_config = File.expand_path(File.join(File.dirname(__FILE__), '..', 'config.json.example'))
  target_config = File.expand_path(options[:config])
  if File.exist?(target_config)
    unless options[:edit_params]
      puts 'FATAL: config already exists. To create default please remove config first.'
      abort
    end
  else
    ### Copy Config File ###
    FileUtils.copy(source_config, target_config)
  end
  if options[:edit_params]
    RokuBuilder::ConfigManager.edit_config(config: target_config, options: options[:edit_params], device: options[:device], project: options[:project], stage: options[:stage])
  end
  exit
end

# load config
config_file = File.expand_path(options[:config])
unless File.exists?(config_file)
  puts "FATAL: Missing config file: #{config_file}"
  abort
end
$config = RokuBuilder::ConfigManager.get_config(config: config_file)
codes = RokuBuilder::ConfigManager.validate_config(config: $config)
fatal = false
codes.each {|code|
  if code > 0
    puts "FATAL: Invalid Config: "+ RokuBuilder::ConfigManager.error_codes()[code]
    fatal = true
  elsif code < 0
    puts "WARNING: Depricated Config: "+ RokuBuilder::ConfigManager.error_codes()[code]
  elsif code == 0 and options[:validate]
    puts "Config Valid"
  end
}
abort if fatal and not options[:validate]

if options[:validate]
  exit
end

#set device
unless options[:device]
  options[:device] = $config[:devices][:default]
end

#set project
if options[:current] or not options[:project]
  path = `pwd`
  project = nil
  $config[:projects].each_pair {|key,value|
    if value.is_a?(Hash)
      repo_path = Pathname.new(value[:directory]).realdirpath.to_s
      if path.start_with?(repo_path)
        project = key
        break
      end
    end
  }
  if project
    options[:project] = project
  else
    options[:project] = $config[:projects][:default]
  end
end

#set outfile
options[:out_folder] = nil
options[:out_file] = nil
if options[:out]
  if options[:out].end_with?(".zip") or options[:out].end_with?(".pkg")
    options[:out_folder], options[:out_file] = Pathname.new(options[:out]).split.map{|p| p.to_s}
  else
    options[:out_folder] = options[:out]
  end
end
unless options[:out_folder]
  options[:out_folder] = "/tmp"
end

# setup configs
device_config = $config[:devices][options[:device].to_sym]
if options[:current]
  pwd = `pwd`.chomp
  unless File.exist?(File.join(pwd, "manifest"))
    puts "FATAL: Current directory does not have a manifest file"
    abort
  end
  project_config = {
    directory: `pwd`.chomp,
    folders: nil,
    files: nil,
    stages: {
      production: {
        branch: nil
      }
    }
  }
else
  project_config = $config[:projects][options[:project].to_sym]
end
unless device_config
  puts "FATAL: Unkown device id"
  abort
end
unless project_config
  puts "FATAL: Unknown project id"
  abort
end
stage = options[:stage].to_sym
unless project_config[:stages][stage]
  puts "FATAL: Unknown stage"
  abort
end
sideload_config = {
  root_dir: project_config[:directory],
  branch: project_config[:stages][stage][:branch],
  update_manifest: false,
  fetch: options[:fetch],
  folders: project_config[:folders],
  files: project_config[:files]
}
build_config = {
  root_dir: project_config[:directory],
  branch: project_config[:stages][stage][:branch],
  fetch: options[:fetch],
  folders: project_config[:folders],
  files: project_config[:files]
}
manifest_config = {
  root_dir: project_config[:directory]
}

if options[:sideload]
  ### Sideload App ###
  # Set options
  loader = RokuBuilder::Loader.new(**device_config)
  if options[:ref]
    sideload_config[:branch] = options[:ref]
  end
  if options[:working]
    sideload_config[:branch] = nil
  end
  # Run
  success = loader.sideload(**sideload_config)
  puts "FATAL: Failed to sideload app" unless success
  abort
elsif options[:package]
  ### Package App ###
  stage_config = project_config[:stages][stage]
  keyer = RokuBuilder::Keyer.new(**device_config)
  loader = RokuBuilder::Loader.new(**device_config)
  packager = RokuBuilder::Packager.new(**device_config)
  inspector = RokuBuilder::Inspector.new(**device_config)
  # Sideload App
  if options[:working]
    sideload_config[:branch] = nil
    puts "WARNING: Packaging working directory"
  end
  sideload_config[:update_manifest] = options[:update_manifest]
  build_version = loader.sideload(**sideload_config)
  unless build_version
    puts "FATAL: Failed to sideload app"
    abort
  end
  # Key Roku
  success = keyer.rekey(**stage_config[:key])
  puts "WARNING: Key did not change" unless success
  # Package App
  package_config = {
    app_name_version: "#{project_config[:app_name]} - #{stage} - #{build_version}",
    password: stage_config[:key][:password],
  }
  if options[:out_file]
    package_config[:out_file] = File.join(options[:out_folder], options[:out_file])
  else
    package_config[:out_file] = File.join(options[:out_folder], "#{project_config[:app_name]}_#{stage}_#{build_version}.pkg")
  end
  success = packager.package(**package_config)
  if success
    puts "Signing Successful: #{package_config[:out_file]}"
  else
    puts "FATAL: Signing Failed"
    abort
  end
  if options[:inspect]
    info = inspector.inspect(pkg: package_config[:out_file], password: stage_config[:key][:password])
    puts "App Name: #{info[:app_name]}"
    puts "Dev ID: #{info[:dev_id]}"
    puts "Creation Date: #{info[:creation_date]}"
    puts "dev.zip: #{info[:dev_zip]}"
  end
elsif options[:build]
  # Check Options
  count = 0
  count += 1 if options[:ref]
  count += 1 if options[:set_stage]
  count += 1 if options[:working]
  count += 1 if options[:current]
  if count > 1
    puts "FATAL: only use one of --ref, --working, --current or --stage"
    abort
  end
  # Set options
  loader = RokuBuilder::Loader.new(**device_config)
  if options[:ref]
    build_config[:branch] = options[:ref]
  end
  if options[:working]
    build_config[:branch] = nil
  end
  build_version = RokuBuilder::ManifestManager.build_version(**manifest_config)
  if options[:out_file]
    build_config[:outfile] = File.join(options[:out_folder], options[:out_file])
  elsif not options[:current]
    build_config[:outfile] = File.join(options[:out_folder],"#{project_config[:app_name]}_#{stage}_#{build_version}.zip")
  end
  # Run
  outfile = loader.build(**build_config)
  puts "Build: #{outfile}"
elsif options[:update]
  old_version = RokuBuilder::ManifestManager.build_version(**manifest_config)
  new_version = RokuBuilder::ManifestManager.update_build(**manifest_config)
  puts "Update build version from:\n#{old_version}\nto:\n#{new_version}"
elsif options[:test]
  ### Test App ###
  tester = RokuBuilder::Tester.new(**device_config)
  test_config = {
    root_dir: project_config[:directory],
    branch: project_config[:testing][:branch],
  }
  if options[:working]
    test_config[:branch] = nil
  end
  tester.run_tests(**test_config)
elsif options[:deeplink]
  ### Deeplink to App ###
  deeplink_config = {
    options: options[:deeplink_options]
  }
  linker = RokuBuilder::Linker.new(**device_config)
  success = linker.link(**deeplink_config)
  puts "FATAL: must supply at least one option for deeplinking" unless success
elsif options[:delete]
  loader = RokuBuilder::Loader.new(**device_config)
  loader.unload()
elsif options[:monitor]
  monitor = RokuBuilder::Monitor.new(**device_config)
  monitor.monitor(type: options[:monitor].to_sym)
elsif options[:navigate]
  navigator = RokuBuilder::Navigator.new(**device_config)
  unless navigator.nav(command: options[:navigate].to_sym)
    puts "FATAL: command not sent"
    abort
  end
elsif options[:restart]
  navigator = RokuBuilder::Navigator.new(**device_config)
  navigator.nav(command: :home)
  sleep(0.9)
  navigator.nav(command: :up)
  sleep(0.9)
  navigator.nav(command: :select)
  navigator.nav(command: :up)
  sleep(0.9)
  navigator.nav(command: :select)
  navigator.nav(command: :up)
  navigator.nav(command: :up)
  navigator.nav(command: :up)
  navigator.nav(command: :up)
  sleep(0.9)
  navigator.nav(command: :select)
  navigator.nav(command: :select)
elsif options[:text]
  navigator = RokuBuilder::Navigator.new(**device_config)
  navigator.type(text: options[:text])
end
